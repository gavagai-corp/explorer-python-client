# coding: utf-8

"""
    Gavagai Explorer API

    <p>This is the technical documentation for the Gavagai Explorer API.</p><p>We recommend that you get familiar with using <a href=\"https://explorer.gavagai.se/\">Gavagai Explorer</a> before you start developing with the API. The Explorer has its own <a href=\"https://gavagai-corp.github.io/explorer/\"> general documentation</a>.</p><p>Make sure that you understand the basic procedures, such as creating projects and uploading texts, exploring and refining your project, or creating reports and applying models. All functionality in Gavagai Explorer is built on this API, so you will have a much easier time understanding the different steps if you have already seen them in the Explorer web interface.</p> <p>The <a href=\"https://gavagai.atlassian.net/wiki/spaces/PUB/pages/99319872/Gavagai+Explorer+API+Tutorial\">Getting Started</a> tutorial and the <a href=\"https://gavagai.atlassian.net/wiki/spaces/PUB/pages/322797577/Explorer+API+Common+Use+Cases\"> Common Use Cases </a>section provide more guidance in understanding how the different API calls can be fitted together to create a workflow. The documentation below then provides full technical specifics for each endpoint.</p>  # noqa: E501

    The version of the OpenAPI document: 3
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from explorer_client.api_client import ApiClient
from explorer_client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class ProjectsApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_folder_to_folder(self, id, sub_folder_id, **kwargs):  # noqa: E501
        """Add sub folder to folder  # noqa: E501

        Adds a sub folder to a folder.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.add_folder_to_folder(id, sub_folder_id, async_req=True)
        >>> result = thread.get()

        :param id: The id of the folder (required)
        :type id: int
        :param sub_folder_id: The id of the sub folder which we will move (required)
        :type sub_folder_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FolderInformation
        """
        kwargs['_return_http_data_only'] = True
        return self.add_folder_to_folder_with_http_info(id, sub_folder_id, **kwargs)  # noqa: E501

    def add_folder_to_folder_with_http_info(self, id, sub_folder_id, **kwargs):  # noqa: E501
        """Add sub folder to folder  # noqa: E501

        Adds a sub folder to a folder.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.add_folder_to_folder_with_http_info(id, sub_folder_id, async_req=True)
        >>> result = thread.get()

        :param id: The id of the folder (required)
        :type id: int
        :param sub_folder_id: The id of the sub folder which we will move (required)
        :type sub_folder_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(FolderInformation, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'sub_folder_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_folder_to_folder" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `add_folder_to_folder`")  # noqa: E501
        # verify the required parameter 'sub_folder_id' is set
        if self.api_client.client_side_validation and ('sub_folder_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['sub_folder_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `sub_folder_id` when calling `add_folder_to_folder`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'sub_folder_id' in local_var_params:
            path_params['subFolderId'] = local_var_params['sub_folder_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "FolderInformation",
        }

        return self.api_client.call_api(
            '/projects/folders/{id}/folders/{subFolderId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def add_project_to_folder(self, id, project_id, **kwargs):  # noqa: E501
        """Add project to folder  # noqa: E501

        Adds a project to a folder  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.add_project_to_folder(id, project_id, async_req=True)
        >>> result = thread.get()

        :param id: The id of the folder (required)
        :type id: int
        :param project_id: The id of the project (required)
        :type project_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FolderInformation
        """
        kwargs['_return_http_data_only'] = True
        return self.add_project_to_folder_with_http_info(id, project_id, **kwargs)  # noqa: E501

    def add_project_to_folder_with_http_info(self, id, project_id, **kwargs):  # noqa: E501
        """Add project to folder  # noqa: E501

        Adds a project to a folder  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.add_project_to_folder_with_http_info(id, project_id, async_req=True)
        >>> result = thread.get()

        :param id: The id of the folder (required)
        :type id: int
        :param project_id: The id of the project (required)
        :type project_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(FolderInformation, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'project_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_project_to_folder" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `add_project_to_folder`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `add_project_to_folder`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "FolderInformation",
        }

        return self.api_client.call_api(
            '/projects/folders/{id}/projects/{projectId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def append_file_to_project(self, id, file, file_name, **kwargs):  # noqa: E501
        """Add data to project  # noqa: E501

        For an authenticated user, this method will upload data and append it to an existing   project. When the data has been uploaded the ProjectStatus changes to ProjectStatus.APPENDING. You may query the project until it changes state to ProjectStatus#EXPLORABLE. The file to append should contain the same number of columns as the previously uploaded files to   the project, but (unlike initial files) no header row. (send a GET to /projects/{id}) until it changes status to EXPLORABLE}. In the case of multipart form data the parts need to be 'file' with the binary data and 'fileName' with the file name as plain text  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.append_file_to_project(id, file, file_name, async_req=True)
        >>> result = thread.get()

        :param id: The numerical id of the project to append to. (required)
        :type id: int
        :param file: input file (required)
        :type file: file
        :param file_name: (required)
        :type file_name: str
        :param encoding: Use this parameter if you know exactly what the encoding of the file is. If nothing is provided a best guess is performed.
        :type encoding: str
        :param message: The message that will be added to the log history.
        :type message: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ProjectId
        """
        kwargs['_return_http_data_only'] = True
        return self.append_file_to_project_with_http_info(id, file, file_name, **kwargs)  # noqa: E501

    def append_file_to_project_with_http_info(self, id, file, file_name, **kwargs):  # noqa: E501
        """Add data to project  # noqa: E501

        For an authenticated user, this method will upload data and append it to an existing   project. When the data has been uploaded the ProjectStatus changes to ProjectStatus.APPENDING. You may query the project until it changes state to ProjectStatus#EXPLORABLE. The file to append should contain the same number of columns as the previously uploaded files to   the project, but (unlike initial files) no header row. (send a GET to /projects/{id}) until it changes status to EXPLORABLE}. In the case of multipart form data the parts need to be 'file' with the binary data and 'fileName' with the file name as plain text  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.append_file_to_project_with_http_info(id, file, file_name, async_req=True)
        >>> result = thread.get()

        :param id: The numerical id of the project to append to. (required)
        :type id: int
        :param file: input file (required)
        :type file: file
        :param file_name: (required)
        :type file_name: str
        :param encoding: Use this parameter if you know exactly what the encoding of the file is. If nothing is provided a best guess is performed.
        :type encoding: str
        :param message: The message that will be added to the log history.
        :type message: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ProjectId, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'file',
            'file_name',
            'encoding',
            'message'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method append_file_to_project" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `append_file_to_project`")  # noqa: E501
        # verify the required parameter 'file' is set
        if self.api_client.client_side_validation and ('file' not in local_var_params or  # noqa: E501
                                                        local_var_params['file'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `file` when calling `append_file_to_project`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if self.api_client.client_side_validation and ('file_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['file_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `file_name` when calling `append_file_to_project`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []
        if 'encoding' in local_var_params and local_var_params['encoding'] is not None:  # noqa: E501
            query_params.append(('encoding', local_var_params['encoding']))  # noqa: E501
        if 'message' in local_var_params and local_var_params['message'] is not None:  # noqa: E501
            query_params.append(('message', local_var_params['message']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in local_var_params:
            local_var_files['file'] = local_var_params['file']  # noqa: E501
        if 'file_name' in local_var_params:
            form_params.append(('fileName', local_var_params['file_name']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        response_types_map = {
            200: "ProjectId",
        }

        return self.api_client.call_api(
            '/projects/{id}/append', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def append_to_project(self, id, rows_data, **kwargs):  # noqa: E501
        """Add data to project  # noqa: E501

        For an authenticated user, this method will upload data and append it to an existing project. When the data has been uploaded the ProjectStatus changes to ProjectStatus.APPENDING. You may query the project until it changes state to ProjectStatus#EXPLORABLE. The file to append should contain the same number of columns as the previously uploaded files to   the project, but (unlike initial files) no header row. (send a GET to /projects/{id}) until it changes status to EXPLORABLE}.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.append_to_project(id, rows_data, async_req=True)
        >>> result = thread.get()

        :param id: The numerical id of the project to append to. (required)
        :type id: int
        :param rows_data: the rows to append (required)
        :type rows_data: RowsData
        :param encoding: Use this parameter if you know exactly what the encoding of the file is. If nothing is provided a best guess is performed.
        :type encoding: str
        :param message: The message that will be added to the log history.
        :type message: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ProjectId
        """
        kwargs['_return_http_data_only'] = True
        return self.append_to_project_with_http_info(id, rows_data, **kwargs)  # noqa: E501

    def append_to_project_with_http_info(self, id, rows_data, **kwargs):  # noqa: E501
        """Add data to project  # noqa: E501

        For an authenticated user, this method will upload data and append it to an existing   project. When the data has been uploaded the ProjectStatus changes to ProjectStatus.APPENDING. You may query the project until it changes state to ProjectStatus#EXPLORABLE. The file to append should contain the same number of columns as the previously uploaded files to   the project, but (unlike initial files) no header row. (send a GET to /projects/{id}) until it changes status to EXPLORABLE}.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.append_to_project_with_http_info(id, rows_data, async_req=True)
        >>> result = thread.get()

        :param id: The numerical id of the project to append to. (required)
        :type id: int
        :param rows_data: the rows to append (required)
        :type rows_data: RowsData
        :param encoding: Use this parameter if you know exactly what the encoding of the file is. If nothing is provided a best guess is performed.
        :type encoding: str
        :param message: The message that will be added to the log history.
        :type message: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ProjectId, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'rows_data',
            'encoding',
            'message'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method append_to_project" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                       local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `append_to_project`")  # noqa: E501
        # verify the required parameter 'rows_data' is set
        if self.api_client.client_side_validation and ('rows_data' not in local_var_params or  # noqa: E501
                                                       local_var_params['rows_data'] is None):  # noqa: E501
            raise ApiValueError(
                "Missing the required parameter `rows_data` when calling `append_to_project`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []
        if 'encoding' in local_var_params and local_var_params['encoding'] is not None:  # noqa: E501
            query_params.append(('encoding', local_var_params['encoding']))  # noqa: E501
        if 'message' in local_var_params and local_var_params['message'] is not None:  # noqa: E501
            query_params.append(('message', local_var_params['message']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'rows_data' in local_var_params:
            body_params = local_var_params['rows_data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        response_types_map = {
            200: "ProjectId",
        }

        return self.api_client.call_api(
            '/projects/{id}/append', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def create_batch(self, id, **kwargs):  # noqa: E501
        """Start Batch Calculation  # noqa: E501

        This method starts a process where all texts in the request will be matched against all topics in the project. The request can also specify if a tonality calculation should be made. <br/>Maximum number of texts in one batch is 100 and each text can not have more than 32767 characters. One credit per text will deducted from the users account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_batch(id, async_req=True)
        >>> result = thread.get()

        :param id: The id of the project (required)
        :type id: int
        :param batch_request:
        :type batch_request: BatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: BatchId
        """
        kwargs['_return_http_data_only'] = True
        return self.create_batch_with_http_info(id, **kwargs)  # noqa: E501

    def create_batch_with_http_info(self, id, **kwargs):  # noqa: E501
        """Start Batch Calculation  # noqa: E501

        This method starts a process where all texts in the request will be matched against all topics in the project. The request can also specify if a tonality calculation should be made. <br/>Maximum number of texts in one batch is 100 and each text can not have more than 32767 characters. One credit per text will deducted from the users account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_batch_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: The id of the project (required)
        :type id: int
        :param batch_request:
        :type batch_request: BatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(BatchId, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'batch_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_batch" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `create_batch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'batch_request' in local_var_params:
            body_params = local_var_params['batch_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "BatchId",
        }

        return self.api_client.call_api(
            '/projects/{id}/batches', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def create_folder(self, folder_request, **kwargs):  # noqa: E501
        """Create folder  # noqa: E501

        Creates a folder in user's account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_folder(folder_request, async_req=True)
        >>> result = thread.get()

        :param folder_request: The request (required)
        :type folder_request: FolderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FolderInformation
        """
        kwargs['_return_http_data_only'] = True
        return self.create_folder_with_http_info(folder_request, **kwargs)  # noqa: E501

    def create_folder_with_http_info(self, folder_request, **kwargs):  # noqa: E501
        """Create folder  # noqa: E501

        Creates a folder in user's account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_folder_with_http_info(folder_request, async_req=True)
        >>> result = thread.get()

        :param folder_request: The request (required)
        :type folder_request: FolderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(FolderInformation, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'folder_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_folder" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'folder_request' is set
        if self.api_client.client_side_validation and ('folder_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['folder_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `folder_request` when calling `create_folder`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'folder_request' in local_var_params:
            body_params = local_var_params['folder_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "FolderInformation",
        }

        return self.api_client.call_api(
            '/projects/folders', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def create_report(self, id, type, **kwargs):  # noqa: E501
        """Create report  # noqa: E501

        Begins to generates a report of the current contents in the project. Note that although this is a POST request, the parameters are passed through the URL. To check the progress of the requested report, call a GET request on /projects/{id}/reports and refer to the corresponding report id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_report(id, type, async_req=True)
        >>> result = thread.get()

        :param id: The identifier for the project (required)
        :type id: int
        :param type: The type of report to generate, for example 'EXCEL' or 'PDF'. (required)
        :type type: str
        :param pole_id: The id of the pole or concept to filter texts by (if desired). Corresponds to target concept in the GUI.
        :type pole_id: int
        :param pole_ids: The ids of the poles (soon concepts) to analyse for strength in the texts.
        :type pole_ids: list[int]
        :param keywords: Boolean to control if keywords columns will be created.
        :type keywords: bool
        :param topic_ids: ids of topics that you want to get the sentiment scores for them for each individual text. When you specify a topicId here, each text in your project will be analyzed with respect to the sentiments around that topic, and columns for the combination of the topic and each sentiment will be added to the resulting report. To find out the topic ids for the project, call GET on /projects/{id}/explore, to see the current ProjectExplorationResponse.
        :type topic_ids: list[int]
        :param sort_alphabetically: Turn on alphabetically sorted topics.
        :type sort_alphabetically: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ProjectReport
        """
        kwargs['_return_http_data_only'] = True
        return self.create_report_with_http_info(id, type, **kwargs)  # noqa: E501

    def create_report_with_http_info(self, id, type, **kwargs):  # noqa: E501
        """Create report  # noqa: E501

        Begins to generates a report of the current contents in the project. Note that although this is a POST request, the parameters are passed through the URL. To check the progress of the requested report, call a GET request on /projects/{id}/reports and refer to the corresponding report id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_report_with_http_info(id, type, async_req=True)
        >>> result = thread.get()

        :param id: The identifier for the project (required)
        :type id: int
        :param type: The type of report to generate, for example 'EXCEL' or 'PDF'. (required)
        :type type: str
        :param pole_id: The id of the pole or concept to filter texts by (if desired). Corresponds to target concept in the GUI.
        :type pole_id: int
        :param pole_ids: The ids of the poles (soon concepts) to analyse for strength in the texts.
        :type pole_ids: list[int]
        :param keywords: Boolean to control if keywords columns will be created.
        :type keywords: bool
        :param topic_ids: ids of topics that you want to get the sentiment scores for them for each individual text. When you specify a topicId here, each text in your project will be analyzed with respect to the sentiments around that topic, and columns for the combination of the topic and each sentiment will be added to the resulting report. To find out the topic ids for the project, call GET on /projects/{id}/explore, to see the current ProjectExplorationResponse.
        :type topic_ids: list[int]
        :param sort_alphabetically: Turn on alphabetically sorted topics.
        :type sort_alphabetically: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ProjectReport, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'type',
            'pole_id',
            'pole_ids',
            'keywords',
            'topic_ids',
            'sort_alphabetically'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_report" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `create_report`")  # noqa: E501
        # verify the required parameter 'type' is set
        if self.api_client.client_side_validation and ('type' not in local_var_params or  # noqa: E501
                                                        local_var_params['type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `type` when calling `create_report`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
        if 'pole_id' in local_var_params and local_var_params['pole_id'] is not None:  # noqa: E501
            query_params.append(('poleId', local_var_params['pole_id']))  # noqa: E501
        if 'pole_ids' in local_var_params and local_var_params['pole_ids'] is not None:  # noqa: E501
            query_params.append(('poleIds', local_var_params['pole_ids']))  # noqa: E501
            collection_formats['poleIds'] = 'multi'  # noqa: E501
        if 'keywords' in local_var_params and local_var_params['keywords'] is not None:  # noqa: E501
            query_params.append(('keywords', local_var_params['keywords']))  # noqa: E501
        if 'topic_ids' in local_var_params and local_var_params['topic_ids'] is not None:  # noqa: E501
            query_params.append(('topicIds', local_var_params['topic_ids']))  # noqa: E501
            collection_formats['topicIds'] = 'multi'  # noqa: E501
        if 'sort_alphabetically' in local_var_params and local_var_params['sort_alphabetically'] is not None:  # noqa: E501
            query_params.append(('sortAlphabetically', local_var_params['sort_alphabetically']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "ProjectReport",
        }

        return self.api_client.call_api(
            '/projects/{id}/reports', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def create_stories(self, id, stories_request, **kwargs):  # noqa: E501
        """Create Stories  # noqa: E501

        Creates stories for the given title and url column. The project needs to be explored before you can call this method. If you have created stories it will appear as a column in the report.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_stories(id, stories_request, async_req=True)
        >>> result = thread.get()

        :param id: The id of the project (required)
        :type id: int
        :param stories_request: The request containing the required data for the stories generation (required)
        :type stories_request: StoriesRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.create_stories_with_http_info(id, stories_request, **kwargs)  # noqa: E501

    def create_stories_with_http_info(self, id, stories_request, **kwargs):  # noqa: E501
        """Create Stories  # noqa: E501

        Creates stories for the given title and url column. The project needs to be explored before you can call this method. If you have created stories it will appear as a column in the report.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_stories_with_http_info(id, stories_request, async_req=True)
        >>> result = thread.get()

        :param id: The id of the project (required)
        :type id: int
        :param stories_request: The request containing the required data for the stories generation (required)
        :type stories_request: StoriesRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'id',
            'stories_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_stories" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `create_stories`")  # noqa: E501
        # verify the required parameter 'stories_request' is set
        if self.api_client.client_side_validation and ('stories_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['stories_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `stories_request` when calling `create_stories`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'stories_request' in local_var_params:
            body_params = local_var_params['stories_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/projects/{id}/stories', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def explore_project(self, id, project_exploration_context, **kwargs):  # noqa: E501
        """Explore project  # noqa: E501

        Starts an exploration of the project. This is only possible if the project has the  ProjectStatus.EXPLORABLE status. This call will return instantly after starting the explore process (with HTTP status 204  since there will be no content). You should supply a ProjectExplorationContext giving the specifics of the exploration. Use the same call but with GET to get a status for the explore process.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.explore_project(id, project_exploration_context, async_req=True)
        >>> result = thread.get()

        :param id: The id of the project to explore (required)
        :type id: int
        :param project_exploration_context: The exploration context to use (required)
        :type project_exploration_context: ProjectExplorationContext
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.explore_project_with_http_info(id, project_exploration_context, **kwargs)  # noqa: E501

    def explore_project_with_http_info(self, id, project_exploration_context, **kwargs):  # noqa: E501
        """Explore project  # noqa: E501

        Starts an exploration of the project. This is only possible if the project has the  ProjectStatus.EXPLORABLE status. This call will return instantly after starting the explore process (with HTTP status 204  since there will be no content). You should supply a ProjectExplorationContext giving the specifics of the exploration. Use the same call but with GET to get a status for the explore process.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.explore_project_with_http_info(id, project_exploration_context, async_req=True)
        >>> result = thread.get()

        :param id: The id of the project to explore (required)
        :type id: int
        :param project_exploration_context: The exploration context to use (required)
        :type project_exploration_context: ProjectExplorationContext
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'id',
            'project_exploration_context'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method explore_project" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `explore_project`")  # noqa: E501
        # verify the required parameter 'project_exploration_context' is set
        if self.api_client.client_side_validation and ('project_exploration_context' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_exploration_context'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_exploration_context` when calling `explore_project`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'project_exploration_context' in local_var_params:
            body_params = local_var_params['project_exploration_context']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/projects/{id}/explore', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def find_suggestions(self, id, suggestions_request, **kwargs):  # noqa: E501
        """Get suggestions for terms  # noqa: E501

        Get suggestions for topics terms. This endpoint retrieves semantically similar words from the Gavagai Lexicon for each term in the request body. These words are filtered so that suggestions returned are only those that are present in the project text data. The response body contains much more detailed information than that which is presented in the GUI, such as a neighbourCounter (how many terms in the request a suggestion is relevant for) and whether the suggestion displays string similarity with any request term.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.find_suggestions(id, suggestions_request, async_req=True)
        >>> result = thread.get()

        :param id: The identifier of the project (required)
        :type id: int
        :param suggestions_request: The request containing relevant terms (required)
        :type suggestions_request: SuggestionsRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SuggestionsResult
        """
        kwargs['_return_http_data_only'] = True
        return self.find_suggestions_with_http_info(id, suggestions_request, **kwargs)  # noqa: E501

    def find_suggestions_with_http_info(self, id, suggestions_request, **kwargs):  # noqa: E501
        """Get suggestions for terms  # noqa: E501

        Get suggestions for topics terms. This endpoint retrieves semantically similar words from the Gavagai Lexicon for each term in the request body. These words are filtered so that suggestions returned are only those that are present in the project text data. The response body contains much more detailed information than that which is presented in the GUI, such as a neighbourCounter (how many terms in the request a suggestion is relevant for) and whether the suggestion displays string similarity with any request term.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.find_suggestions_with_http_info(id, suggestions_request, async_req=True)
        >>> result = thread.get()

        :param id: The identifier of the project (required)
        :type id: int
        :param suggestions_request: The request containing relevant terms (required)
        :type suggestions_request: SuggestionsRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SuggestionsResult, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'suggestions_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_suggestions" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `find_suggestions`")  # noqa: E501
        # verify the required parameter 'suggestions_request' is set
        if self.api_client.client_side_validation and ('suggestions_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['suggestions_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `suggestions_request` when calling `find_suggestions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'suggestions_request' in local_var_params:
            body_params = local_var_params['suggestions_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "SuggestionsResult",
        }

        return self.api_client.call_api(
            '/projects/{id}/suggestions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def get_batch_result(self, id, batch_id, **kwargs):  # noqa: E501
        """Get Batch Calculation  # noqa: E501

        Get the results of the batch calculation process. Once the results are available and retrieved successfully the result will be deleted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_batch_result(id, batch_id, async_req=True)
        >>> result = thread.get()

        :param id: The id of the project (required)
        :type id: int
        :param batch_id: The id of the created batch request (required)
        :type batch_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: BatchId
        """
        kwargs['_return_http_data_only'] = True
        return self.get_batch_result_with_http_info(id, batch_id, **kwargs)  # noqa: E501

    def get_batch_result_with_http_info(self, id, batch_id, **kwargs):  # noqa: E501
        """Get Batch Calculation  # noqa: E501

        Get the results of the batch calculation process. Once the results are available and retrieved successfully the result will be deleted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_batch_result_with_http_info(id, batch_id, async_req=True)
        >>> result = thread.get()

        :param id: The id of the project (required)
        :type id: int
        :param batch_id: The id of the created batch request (required)
        :type batch_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(BatchId, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'batch_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_batch_result" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `get_batch_result`")  # noqa: E501
        # verify the required parameter 'batch_id' is set
        if self.api_client.client_side_validation and ('batch_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['batch_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `batch_id` when calling `get_batch_result`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'batch_id' in local_var_params:
            path_params['batchId'] = local_var_params['batch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "BatchId",
        }

        return self.api_client.call_api(
            '/projects/{id}/batches/{batchId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def get_cell_information(self, id, **kwargs):  # noqa: E501
        """Get cell data  # noqa: E501

        Return a CellTopicInformation for the given range which includes the matching topics, sentiment scores and metadata information for the corresponding texts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_cell_information(id, async_req=True)
        >>> result = thread.get()

        :param id: The numerical id of the project (required)
        :type id: int
        :param header_ids: The ids of the columns that you would like to receive as extra data with every row
        :type header_ids: list[int]
        :param first_result: Where to start reading cells. Defaults to 0, which means the first pageSize number of cells
        :type first_result: int
        :param page_size: The number of cells to return. Defaults to 100, max 1000
        :type page_size: int
        :param calculate_tonality: Boolean value indicating if tonality should be calculated
        :type calculate_tonality: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CellTopicInformation
        """
        kwargs['_return_http_data_only'] = True
        return self.get_cell_information_with_http_info(id, **kwargs)  # noqa: E501

    def get_cell_information_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get cell data  # noqa: E501

        Return a CellTopicInformation for the given range which includes the matching topics, sentiment scores and metadata information for the corresponding texts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_cell_information_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: The numerical id of the project (required)
        :type id: int
        :param header_ids: The ids of the columns that you would like to receive as extra data with every row
        :type header_ids: list[int]
        :param first_result: Where to start reading cells. Defaults to 0, which means the first pageSize number of cells
        :type first_result: int
        :param page_size: The number of cells to return. Defaults to 100, max 1000
        :type page_size: int
        :param calculate_tonality: Boolean value indicating if tonality should be calculated
        :type calculate_tonality: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CellTopicInformation, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'header_ids',
            'first_result',
            'page_size',
            'calculate_tonality'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cell_information" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `get_cell_information`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []
        if 'header_ids' in local_var_params and local_var_params['header_ids'] is not None:  # noqa: E501
            query_params.append(('headerIds', local_var_params['header_ids']))  # noqa: E501
            collection_formats['headerIds'] = 'multi'  # noqa: E501
        if 'first_result' in local_var_params and local_var_params['first_result'] is not None:  # noqa: E501
            query_params.append(('firstResult', local_var_params['first_result']))  # noqa: E501
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'calculate_tonality' in local_var_params and local_var_params['calculate_tonality'] is not None:  # noqa: E501
            query_params.append(('calculateTonality', local_var_params['calculate_tonality']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "CellTopicInformation",
        }

        return self.api_client.call_api(
            '/projects/{id}/result/cells', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def get_coverage_tonalities(self, id, **kwargs):  # noqa: E501
        """Get Coverage Tonalities  # noqa: E501

        Get tonalities for documents not covered by existing topic structure. Includes tonality scores broken down for each unclassified document and an aggregated score for all such documents. This call is asynchronous: the information must first be requested through a POST call to the same endpoint (see below).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_coverage_tonalities(id, async_req=True)
        >>> result = thread.get()

        :param id: The id of the project (required)
        :type id: int
        :param first_result: An index into all available examples matching combination of terms and association. Defaults to 0, which means the first pageSize number of examples. Note that this is a paginated API, controlled using the firstResult and pageSize parameters.
        :type first_result: int
        :param page_size: The number of examples to return. Defaults to 15.
        :type page_size: int
        :param filter_by_tonality: Filter by tonality
        :type filter_by_tonality: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TonalitiesResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.get_coverage_tonalities_with_http_info(id, **kwargs)  # noqa: E501

    def get_coverage_tonalities_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Coverage Tonalities  # noqa: E501

        Get tonalities for documents not covered by existing topic structure. Includes tonality scores broken down for each unclassified document and an aggregated score for all such documents. This call is asynchronous: the information must first be requested through a POST call to the same endpoint (see below).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_coverage_tonalities_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: The id of the project (required)
        :type id: int
        :param first_result: An index into all available examples matching combination of terms and association. Defaults to 0, which means the first pageSize number of examples. Note that this is a paginated API, controlled using the firstResult and pageSize parameters.
        :type first_result: int
        :param page_size: The number of examples to return. Defaults to 15.
        :type page_size: int
        :param filter_by_tonality: Filter by tonality
        :type filter_by_tonality: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TonalitiesResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'first_result',
            'page_size',
            'filter_by_tonality'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_coverage_tonalities" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `get_coverage_tonalities`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []
        if 'first_result' in local_var_params and local_var_params['first_result'] is not None:  # noqa: E501
            query_params.append(('firstResult', local_var_params['first_result']))  # noqa: E501
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'filter_by_tonality' in local_var_params and local_var_params['filter_by_tonality'] is not None:  # noqa: E501
            query_params.append(('filterByTonality', local_var_params['filter_by_tonality']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "TonalitiesResponse",
        }

        return self.api_client.call_api(
            '/projects/{id}/explore/coverageStatistics/tonalities', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def get_distinct_column_values(self, id, column_header_id, **kwargs):  # noqa: E501
        """Get distinct column values  # noqa: E501

        When you want to create a filter you need to know the different existing values in the filter column. This method retrieves the distinct values of a given column in a given project. You may wish to check if the column is actually filterable by looking at the information given in the project. If you try this method on a non-filterable column you will get an error. Once you have at least two values you can create filters with one or more of them and other columns as well. Example: if the 'filterable' column contains many rows of 'male' or 'female' or 'unspecified', this call will return the set of three possible filter values 'male', 'female', and 'unspecified'.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_distinct_column_values(id, column_header_id, async_req=True)
        >>> result = thread.get()

        :param id: The identifier for the project from which to retrieve the column values (required)
        :type id: int
        :param column_header_id: The header identifier for the column for which to retrieve the distinct values (required)
        :type column_header_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[str]
        """
        kwargs['_return_http_data_only'] = True
        return self.get_distinct_column_values_with_http_info(id, column_header_id, **kwargs)  # noqa: E501

    def get_distinct_column_values_with_http_info(self, id, column_header_id, **kwargs):  # noqa: E501
        """Get distinct column values  # noqa: E501

        When you want to create a filter you need to know the different existing values in the filter column. This method retrieves the distinct values of a given column in a given project. You may wish to check if the column is actually filterable by looking at the information given in the project. If you try this method on a non-filterable column you will get an error. Once you have at least two values you can create filters with one or more of them and other columns as well. Example: if the 'filterable' column contains many rows of 'male' or 'female' or 'unspecified', this call will return the set of three possible filter values 'male', 'female', and 'unspecified'.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_distinct_column_values_with_http_info(id, column_header_id, async_req=True)
        >>> result = thread.get()

        :param id: The identifier for the project from which to retrieve the column values (required)
        :type id: int
        :param column_header_id: The header identifier for the column for which to retrieve the distinct values (required)
        :type column_header_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[str], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'column_header_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_distinct_column_values" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `get_distinct_column_values`")  # noqa: E501
        # verify the required parameter 'column_header_id' is set
        if self.api_client.client_side_validation and ('column_header_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['column_header_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `column_header_id` when calling `get_distinct_column_values`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'column_header_id' in local_var_params:
            path_params['columnHeaderId'] = local_var_params['column_header_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "list[str]",
        }

        return self.api_client.call_api(
            '/projects/{id}/columns/{columnHeaderId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def get_exploration(self, id, **kwargs):  # noqa: E501
        """Get Explore Results  # noqa: E501

        Retrieves the result of a project exploration if it is ready, and the status of the project exploration while it is ongoing.  <p></p>Use this method for polling the status of a recently started exploration (see POST  documentation for the same endpoint). When the status indicates that the exploration has been  completed use the same method to retrieve the result. The possible states are in  ExplorationState. The exploration starts in the ExplorationState.STARTED state and finishes in  ExplorationState.FINISHED.You may get the state ExplorationState.TIMEOUT if the process did not finish within the permitted time range (because the project contains  too much data). If there was a problem and the state is ExplorationState.ERROR you can check the status message for the reason.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_exploration(id, async_req=True)
        >>> result = thread.get()

        :param id: The id of the project to explore (required)
        :type id: int
        :param retry: Tf current status is TIMEOUT or ERROR, setting retry to true means that a new explore session is beeing started with the latest context
        :type retry: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ProjectExplorationResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.get_exploration_with_http_info(id, **kwargs)  # noqa: E501

    def get_exploration_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Explore Results  # noqa: E501

        Retrieves the result of a project exploration if it is ready, and the status of the project exploration while it is ongoing.  <p></p>Use this method for polling the status of a recently started exploration (see POST  documentation for the same endpoint). When the status indicates that the exploration has been  completed use the same method to retrieve the result. The possible states are in  ExplorationState. The exploration starts in the ExplorationState.STARTED state and finishes in  ExplorationState.FINISHED.You may get the state ExplorationState.TIMEOUT if the process did not finish within the permitted time range (because the project contains  too much data). If there was a problem and the state is ExplorationState.ERROR you can check the status message for the reason.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_exploration_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: The id of the project to explore (required)
        :type id: int
        :param retry: Tf current status is TIMEOUT or ERROR, setting retry to true means that a new explore session is beeing started with the latest context
        :type retry: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ProjectExplorationResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'retry'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_exploration" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `get_exploration`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []
        if 'retry' in local_var_params and local_var_params['retry'] is not None:  # noqa: E501
            query_params.append(('retry', local_var_params['retry']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "ProjectExplorationResponse",
        }

        return self.api_client.call_api(
            '/projects/{id}/explore', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def get_folder(self, id, **kwargs):  # noqa: E501
        """Get folder  # noqa: E501

        Gets the content of the given folder  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_folder(id, async_req=True)
        >>> result = thread.get()

        :param id: The id of the folder (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FolderInformation
        """
        kwargs['_return_http_data_only'] = True
        return self.get_folder_with_http_info(id, **kwargs)  # noqa: E501

    def get_folder_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get folder  # noqa: E501

        Gets the content of the given folder  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_folder_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: The id of the folder (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(FolderInformation, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_folder" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `get_folder`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "FolderInformation",
        }

        return self.api_client.call_api(
            '/projects/folders/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def get_folders(self, **kwargs):  # noqa: E501
        """Get folders  # noqa: E501

        Get a user's folders and projects  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_folders(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FolderStructure
        """
        kwargs['_return_http_data_only'] = True
        return self.get_folders_with_http_info(**kwargs)  # noqa: E501

    def get_folders_with_http_info(self, **kwargs):  # noqa: E501
        """Get folders  # noqa: E501

        Get a user's folders and projects  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_folders_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(FolderStructure, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_folders" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "FolderStructure",
        }

        return self.api_client.call_api(
            '/projects/folders', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def get_group_tonalities(self, id, group_id, **kwargs):  # noqa: E501
        """Get tonality response  # noqa: E501

        Get result of a group tonality calculation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_group_tonalities(id, group_id, async_req=True)
        >>> result = thread.get()

        :param id: The project identifier (required)
        :type id: int
        :param group_id: The group identifier. (required)
        :type group_id: int
        :param first_result: An index into all available examples matching combination of terms and association. Defaults to 0, which means the first pageSize number of examples.
        :type first_result: int
        :param page_size: The number of examples to return. Defaults to 15.
        :type page_size: int
        :param filter_by_tonality: Filter the sentences by only keeping sentences that has a score above 0 for the given tonality.
        :type filter_by_tonality: bool
        :param meta_data_columns: Comma separated array of column header id:s which row data will be returned.
        :type meta_data_columns: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TonalitiesResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.get_group_tonalities_with_http_info(id, group_id, **kwargs)  # noqa: E501

    def get_group_tonalities_with_http_info(self, id, group_id, **kwargs):  # noqa: E501
        """Get tonality response  # noqa: E501

        Get result of a group tonality calculation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_group_tonalities_with_http_info(id, group_id, async_req=True)
        >>> result = thread.get()

        :param id: The project identifier (required)
        :type id: int
        :param group_id: The group identifier. (required)
        :type group_id: int
        :param first_result: An index into all available examples matching combination of terms and association. Defaults to 0, which means the first pageSize number of examples.
        :type first_result: int
        :param page_size: The number of examples to return. Defaults to 15.
        :type page_size: int
        :param filter_by_tonality: Filter the sentences by only keeping sentences that has a score above 0 for the given tonality.
        :type filter_by_tonality: bool
        :param meta_data_columns: Comma separated array of column header id:s which row data will be returned.
        :type meta_data_columns: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TonalitiesResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'group_id',
            'first_result',
            'page_size',
            'filter_by_tonality',
            'meta_data_columns'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_group_tonalities" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `get_group_tonalities`")  # noqa: E501
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['group_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `group_id` when calling `get_group_tonalities`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'group_id' in local_var_params:
            path_params['groupId'] = local_var_params['group_id']  # noqa: E501

        query_params = []
        if 'first_result' in local_var_params and local_var_params['first_result'] is not None:  # noqa: E501
            query_params.append(('firstResult', local_var_params['first_result']))  # noqa: E501
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'filter_by_tonality' in local_var_params and local_var_params['filter_by_tonality'] is not None:  # noqa: E501
            query_params.append(('filterByTonality', local_var_params['filter_by_tonality']))  # noqa: E501
        if 'meta_data_columns' in local_var_params and local_var_params['meta_data_columns'] is not None:  # noqa: E501
            query_params.append(('metaDataColumns', local_var_params['meta_data_columns']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "TonalitiesResponse",
        }

        return self.api_client.call_api(
            '/projects/{id}/explore/groups/{groupId}/tonalities', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def get_matching_sentences_for_terms(self, id, terms, **kwargs):  # noqa: E501
        """Get sentences  # noqa: E501

        Get sentences matching any of the specified terms. The project must be explored prior to making this request  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_matching_sentences_for_terms(id, terms, async_req=True)
        >>> result = thread.get()

        :param id: The id of the project (required)
        :type id: int
        :param terms: The terms for which sentences must be retrieved (required)
        :type terms: list[str]
        :param max_sentences: The maximum number of sentences to include (maximum 20). The actual number will be equal or less to the number specified
        :type max_sentences: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Sentences
        """
        kwargs['_return_http_data_only'] = True
        return self.get_matching_sentences_for_terms_with_http_info(id, terms, **kwargs)  # noqa: E501

    def get_matching_sentences_for_terms_with_http_info(self, id, terms, **kwargs):  # noqa: E501
        """Get sentences  # noqa: E501

        Get sentences matching any of the specified terms. The project must be explored prior to making this request  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_matching_sentences_for_terms_with_http_info(id, terms, async_req=True)
        >>> result = thread.get()

        :param id: The id of the project (required)
        :type id: int
        :param terms: The terms for which sentences must be retrieved (required)
        :type terms: list[str]
        :param max_sentences: The maximum number of sentences to include (maximum 20). The actual number will be equal or less to the number specified
        :type max_sentences: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Sentences, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'terms',
            'max_sentences'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_matching_sentences_for_terms" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `get_matching_sentences_for_terms`")  # noqa: E501
        # verify the required parameter 'terms' is set
        if self.api_client.client_side_validation and ('terms' not in local_var_params or  # noqa: E501
                                                        local_var_params['terms'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `terms` when calling `get_matching_sentences_for_terms`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []
        if 'terms' in local_var_params and local_var_params['terms'] is not None:  # noqa: E501
            query_params.append(('terms', local_var_params['terms']))  # noqa: E501
            collection_formats['terms'] = 'multi'  # noqa: E501
        if 'max_sentences' in local_var_params and local_var_params['max_sentences'] is not None:  # noqa: E501
            query_params.append(('maxSentences', local_var_params['max_sentences']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "Sentences",
        }

        return self.api_client.call_api(
            '/projects/{id}/sentences', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def get_project(self, id, **kwargs):  # noqa: E501
        """Get project  # noqa: E501

        Return a {@link com.gavagai.ethersource.api.explorer.marshal.project.Project} for the given projectId. This includes information like project's status, settings, number of rows, time of creation, column headers, history of uploads, etc.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_project(id, async_req=True)
        >>> result = thread.get()

        :param id: The numerical id of the project (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Project
        """
        kwargs['_return_http_data_only'] = True
        return self.get_project_with_http_info(id, **kwargs)  # noqa: E501

    def get_project_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get project  # noqa: E501

        Return a {@link com.gavagai.ethersource.api.explorer.marshal.project.Project} for the given projectId. This includes information like project's status, settings, number of rows, time of creation, column headers, history of uploads, etc.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_project_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: The numerical id of the project (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Project, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `get_project`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "Project",
        }

        return self.api_client.call_api(
            '/projects/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def get_project_document_tonalities(self, id, **kwargs):  # noqa: E501
        """Get Document Tonalities  # noqa: E501

        Returns document tonalities information. The calculation works asynchronously and must first be set in motion by calling a POST method on this same endpoint (documented below). Meta-information about the status of the calculation and a percentage progress is also included. If the calculation has not been started, the status will be NOT_STARTED. Note that this is a paginated API, controlled using the firstResult and pageSize parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_project_document_tonalities(id, async_req=True)
        >>> result = thread.get()

        :param id: The id of the project (required)
        :type id: int
        :param first_result: An index into all available examples matching combination of terms and association. Defaults to 0, which means the first pageSize number of examples.
        :type first_result: int
        :param page_size: The number of examples to return
        :type page_size: int
        :param filter_by_tonality: Filter the sentences by only keeping sentences that has a score above 0 for the given tonality
        :type filter_by_tonality: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TonalitiesResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.get_project_document_tonalities_with_http_info(id, **kwargs)  # noqa: E501

    def get_project_document_tonalities_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Document Tonalities  # noqa: E501

        Returns document tonalities information. The calculation works asynchronously and must first be set in motion by calling a POST method on this same endpoint (documented below). Meta-information about the status of the calculation and a percentage progress is also included. If the calculation has not been started, the status will be NOT_STARTED. Note that this is a paginated API, controlled using the firstResult and pageSize parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_project_document_tonalities_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: The id of the project (required)
        :type id: int
        :param first_result: An index into all available examples matching combination of terms and association. Defaults to 0, which means the first pageSize number of examples.
        :type first_result: int
        :param page_size: The number of examples to return
        :type page_size: int
        :param filter_by_tonality: Filter the sentences by only keeping sentences that has a score above 0 for the given tonality
        :type filter_by_tonality: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TonalitiesResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'first_result',
            'page_size',
            'filter_by_tonality'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project_document_tonalities" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `get_project_document_tonalities`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []
        if 'first_result' in local_var_params and local_var_params['first_result'] is not None:  # noqa: E501
            query_params.append(('firstResult', local_var_params['first_result']))  # noqa: E501
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'filter_by_tonality' in local_var_params and local_var_params['filter_by_tonality'] is not None:  # noqa: E501
            query_params.append(('filterByTonality', local_var_params['filter_by_tonality']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "TonalitiesResponse",
        }

        return self.api_client.call_api(
            '/projects/{id}/explore/projectTonalities/tonalities', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def get_project_languages(self, **kwargs):  # noqa: E501
        """Get all supported languages  # noqa: E501

        This method returns all currently supported languages in the Explorer.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_project_languages(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[str]
        """
        kwargs['_return_http_data_only'] = True
        return self.get_project_languages_with_http_info(**kwargs)  # noqa: E501

    def get_project_languages_with_http_info(self, **kwargs):  # noqa: E501
        """Get all supported languages  # noqa: E501

        This method returns all currently supported languages in the Explorer.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_project_languages_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[str], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project_languages" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "list[str]",
        }

        return self.api_client.call_api(
            '/projects/languages', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def get_project_languages1(self, id, **kwargs):  # noqa: E501
        """Get project languages  # noqa: E501

        Get languages that is available in the project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_project_languages1(id, async_req=True)
        >>> result = thread.get()

        :param id: The project identifier (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[ProjectLanguage]
        """
        kwargs['_return_http_data_only'] = True
        return self.get_project_languages1_with_http_info(id, **kwargs)  # noqa: E501

    def get_project_languages1_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get project languages  # noqa: E501

        Get languages that is available in the project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_project_languages1_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: The project identifier (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[ProjectLanguage], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project_languages1" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `get_project_languages1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "list[ProjectLanguage]",
        }

        return self.api_client.call_api(
            '/projects/{id}/languages', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def get_project_report(self, id, report_id, **kwargs):  # noqa: E501
        """Retrieve report  # noqa: E501

        Retrieve a completed report, according to the format specified when the report was requested (through a POST method to the /{id}/reports endpoint). Note that in the data tab which contains the original data, all cells will be formatted as text, even if they were of a different format originally.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_project_report(id, report_id, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: int
        :param report_id: (required)
        :type report_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: file
        """
        kwargs['_return_http_data_only'] = True
        return self.get_project_report_with_http_info(id, report_id, **kwargs)  # noqa: E501

    def get_project_report_with_http_info(self, id, report_id, **kwargs):  # noqa: E501
        """Retrieve report  # noqa: E501

        Retrieve a completed report, according to the format specified when the report was requested (through a POST method to the /{id}/reports endpoint). Note that in the data tab which contains the original data, all cells will be formatted as text, even if they were of a different format originally.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_project_report_with_http_info(id, report_id, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: int
        :param report_id: (required)
        :type report_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(file, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'report_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project_report" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `get_project_report`")  # noqa: E501
        # verify the required parameter 'report_id' is set
        if self.api_client.client_side_validation and ('report_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['report_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `report_id` when calling `get_project_report`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'report_id' in local_var_params:
            path_params['reportId'] = local_var_params['report_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/pdf', 'application/vnd.ms-excel', 'text/csv'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "file",
        }

        return self.api_client.call_api(
            '/projects/{id}/reports/{reportId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def get_project_reports(self, id, **kwargs):  # noqa: E501
        """Get reports  # noqa: E501

        Get a list of all reports of the given project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_project_reports(id, async_req=True)
        >>> result = thread.get()

        :param id: The identifier for the project (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[ProjectReport]
        """
        kwargs['_return_http_data_only'] = True
        return self.get_project_reports_with_http_info(id, **kwargs)  # noqa: E501

    def get_project_reports_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get reports  # noqa: E501

        Get a list of all reports of the given project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_project_reports_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: The identifier for the project (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[ProjectReport], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project_reports" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `get_project_reports`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "list[ProjectReport]",
        }

        return self.api_client.call_api(
            '/projects/{id}/reports', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def get_projects(self, **kwargs):  # noqa: E501
        """Get all projects  # noqa: E501

        For an authenticated user, this method returns all projects accessible by that user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_projects(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[ProjectInfo]
        """
        kwargs['_return_http_data_only'] = True
        return self.get_projects_with_http_info(**kwargs)  # noqa: E501

    def get_projects_with_http_info(self, **kwargs):  # noqa: E501
        """Get all projects  # noqa: E501

        For an authenticated user, this method returns all projects accessible by that user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_projects_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[ProjectInfo], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_projects" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "list[ProjectInfo]",
        }

        return self.api_client.call_api(
            '/projects', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def get_sample_texts(self, project_id, column_header_id, **kwargs):  # noqa: E501
        """Get sample texts  # noqa: E501

        Returning a chosen number of rows from a given column in your upload file. In the Explorer GUI the returned samples are shown to the user to verify they are selecting the correct column of text data to analyse.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_sample_texts(project_id, column_header_id, async_req=True)
        >>> result = thread.get()

        :param project_id: The id of the project (required)
        :type project_id: int
        :param column_header_id: The id of column header to retrieve samples from. (required)
        :type column_header_id: int
        :param number_of_text_samples: The number of sample texts to return from the corresponding column
        :type number_of_text_samples: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[str]
        """
        kwargs['_return_http_data_only'] = True
        return self.get_sample_texts_with_http_info(project_id, column_header_id, **kwargs)  # noqa: E501

    def get_sample_texts_with_http_info(self, project_id, column_header_id, **kwargs):  # noqa: E501
        """Get sample texts  # noqa: E501

        Returning a chosen number of rows from a given column in your upload file. In the Explorer GUI the returned samples are shown to the user to verify they are selecting the correct column of text data to analyse.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_sample_texts_with_http_info(project_id, column_header_id, async_req=True)
        >>> result = thread.get()

        :param project_id: The id of the project (required)
        :type project_id: int
        :param column_header_id: The id of column header to retrieve samples from. (required)
        :type column_header_id: int
        :param number_of_text_samples: The number of sample texts to return from the corresponding column
        :type number_of_text_samples: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[str], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'project_id',
            'column_header_id',
            'number_of_text_samples'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_sample_texts" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `get_sample_texts`")  # noqa: E501
        # verify the required parameter 'column_header_id' is set
        if self.api_client.client_side_validation and ('column_header_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['column_header_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `column_header_id` when calling `get_sample_texts`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501
        if 'column_header_id' in local_var_params:
            path_params['columnHeaderId'] = local_var_params['column_header_id']  # noqa: E501

        query_params = []
        if 'number_of_text_samples' in local_var_params and local_var_params['number_of_text_samples'] is not None:  # noqa: E501
            query_params.append(('numberOfTextSamples', local_var_params['number_of_text_samples']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "list[str]",
        }

        return self.api_client.call_api(
            '/projects/{projectId}/headers/{columnHeaderId}/samples', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def get_stories(self, id, **kwargs):  # noqa: E501
        """Get Stories  # noqa: E501

        For an authenticated user, this method returns all created stories for the specified project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_stories(id, async_req=True)
        >>> result = thread.get()

        :param id: The id of the project (required)
        :type id: int
        :param header_ids: The ids of the columns that you would like to receive as extra data with every document
        :type header_ids: list[int]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StoriesResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.get_stories_with_http_info(id, **kwargs)  # noqa: E501

    def get_stories_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Stories  # noqa: E501

        For an authenticated user, this method returns all created stories for the specified project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_stories_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: The id of the project (required)
        :type id: int
        :param header_ids: The ids of the columns that you would like to receive as extra data with every document
        :type header_ids: list[int]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StoriesResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'header_ids'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_stories" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `get_stories`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []
        if 'header_ids' in local_var_params and local_var_params['header_ids'] is not None:  # noqa: E501
            query_params.append(('headerIds', local_var_params['header_ids']))  # noqa: E501
            collection_formats['headerIds'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "StoriesResponse",
        }

        return self.api_client.call_api(
            '/projects/{id}/stories', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def get_term_details(self, id, **kwargs):  # noqa: E501
        """Get topic details  # noqa: E501

        Gets the details of topic terms and associations combinations; e.g.text examples and tonality scores.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_term_details(id, async_req=True)
        >>> result = thread.get()

        :param id: The project identifier (required)
        :type id: int
        :param terms: Specify the terms you are interested in getting details for. One query paramter per term like this: ?terms=a_term&amp;terms=some_other_term&amp;...
        :type terms: list[str]
        :param associations: Optionally specify the associations you are interested in as well. Same format as for the terms: ?associations=association1&amp;associations=assoc2
        :type associations: list[str]
        :param first_result: An index into all available examples matching combination of terms and association. Defaults to 0, which means the first pageSize number of examples.
        :type first_result: int
        :param page_size: The number of examples to return. Defaults to 15.
        :type page_size: int
        :param sort_by_tonality: The tonality to sort by. From highest value to lowest
        :type sort_by_tonality: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TermDetails
        """
        kwargs['_return_http_data_only'] = True
        return self.get_term_details_with_http_info(id, **kwargs)  # noqa: E501

    def get_term_details_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get topic details  # noqa: E501

        Gets the details of topic terms and associations combinations; e.g.text examples and tonality scores.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_term_details_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: The project identifier (required)
        :type id: int
        :param terms: Specify the terms you are interested in getting details for. One query paramter per term like this: ?terms=a_term&amp;terms=some_other_term&amp;...
        :type terms: list[str]
        :param associations: Optionally specify the associations you are interested in as well. Same format as for the terms: ?associations=association1&amp;associations=assoc2
        :type associations: list[str]
        :param first_result: An index into all available examples matching combination of terms and association. Defaults to 0, which means the first pageSize number of examples.
        :type first_result: int
        :param page_size: The number of examples to return. Defaults to 15.
        :type page_size: int
        :param sort_by_tonality: The tonality to sort by. From highest value to lowest
        :type sort_by_tonality: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TermDetails, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'terms',
            'associations',
            'first_result',
            'page_size',
            'sort_by_tonality'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_term_details" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `get_term_details`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []
        if 'terms' in local_var_params and local_var_params['terms'] is not None:  # noqa: E501
            query_params.append(('terms', local_var_params['terms']))  # noqa: E501
            collection_formats['terms'] = 'multi'  # noqa: E501
        if 'associations' in local_var_params and local_var_params['associations'] is not None:  # noqa: E501
            query_params.append(('associations', local_var_params['associations']))  # noqa: E501
            collection_formats['associations'] = 'multi'  # noqa: E501
        if 'first_result' in local_var_params and local_var_params['first_result'] is not None:  # noqa: E501
            query_params.append(('firstResult', local_var_params['first_result']))  # noqa: E501
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'sort_by_tonality' in local_var_params and local_var_params['sort_by_tonality'] is not None:  # noqa: E501
            query_params.append(('sortByTonality', local_var_params['sort_by_tonality']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "TermDetails",
        }

        return self.api_client.call_api(
            '/projects/{id}/details', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def get_topic_tonalities(self, id, group_id, topic_id, **kwargs):  # noqa: E501
        """Get tonality response  # noqa: E501

        Get result of a topic tonality calculation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_topic_tonalities(id, group_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param id: The project identifier (required)
        :type id: int
        :param group_id: The group identifier (required)
        :type group_id: int
        :param topic_id: The topic identifier. The topic must belong to the group identified by the groupId parameter (required)
        :type topic_id: int
        :param first_result: An index into all available examples matching combination of terms and association. Defaults to 0, which means the first pageSize number of examples.
        :type first_result: int
        :param page_size: The number of examples to return. Defaults to 15.
        :type page_size: int
        :param filter_by_tonality: Filter the sentences by only keeping sentences that has a score above 0 for the given tonality.
        :type filter_by_tonality: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TonalitiesResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.get_topic_tonalities_with_http_info(id, group_id, topic_id, **kwargs)  # noqa: E501

    def get_topic_tonalities_with_http_info(self, id, group_id, topic_id, **kwargs):  # noqa: E501
        """Get tonality response  # noqa: E501

        Get result of a topic tonality calculation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_topic_tonalities_with_http_info(id, group_id, topic_id, async_req=True)
        >>> result = thread.get()

        :param id: The project identifier (required)
        :type id: int
        :param group_id: The group identifier (required)
        :type group_id: int
        :param topic_id: The topic identifier. The topic must belong to the group identified by the groupId parameter (required)
        :type topic_id: int
        :param first_result: An index into all available examples matching combination of terms and association. Defaults to 0, which means the first pageSize number of examples.
        :type first_result: int
        :param page_size: The number of examples to return. Defaults to 15.
        :type page_size: int
        :param filter_by_tonality: Filter the sentences by only keeping sentences that has a score above 0 for the given tonality.
        :type filter_by_tonality: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TonalitiesResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'group_id',
            'topic_id',
            'first_result',
            'page_size',
            'filter_by_tonality'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_topic_tonalities" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `get_topic_tonalities`")  # noqa: E501
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['group_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `group_id` when calling `get_topic_tonalities`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['topic_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `topic_id` when calling `get_topic_tonalities`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'group_id' in local_var_params:
            path_params['groupId'] = local_var_params['group_id']  # noqa: E501
        if 'topic_id' in local_var_params:
            path_params['topicId'] = local_var_params['topic_id']  # noqa: E501

        query_params = []
        if 'first_result' in local_var_params and local_var_params['first_result'] is not None:  # noqa: E501
            query_params.append(('firstResult', local_var_params['first_result']))  # noqa: E501
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'filter_by_tonality' in local_var_params and local_var_params['filter_by_tonality'] is not None:  # noqa: E501
            query_params.append(('filterByTonality', local_var_params['filter_by_tonality']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "TonalitiesResponse",
        }

        return self.api_client.call_api(
            '/projects/{id}/explore/groups/{groupId}/topics/{topicId}/tonalities', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def remove_folder(self, id, **kwargs):  # noqa: E501
        """Remove folder  # noqa: E501

        Removes the folder and the projects and sub folders that are in the folder.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.remove_folder(id, async_req=True)
        >>> result = thread.get()

        :param id: The id of the folder. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.remove_folder_with_http_info(id, **kwargs)  # noqa: E501

    def remove_folder_with_http_info(self, id, **kwargs):  # noqa: E501
        """Remove folder  # noqa: E501

        Removes the folder and the projects and sub folders that are in the folder.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.remove_folder_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: The id of the folder. (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_folder" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `remove_folder`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/projects/folders/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def remove_folder_from_folder(self, id, sub_folder_id, **kwargs):  # noqa: E501
        """Remove sub folder from folder  # noqa: E501

        Remove a sub folder from a folder  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.remove_folder_from_folder(id, sub_folder_id, async_req=True)
        >>> result = thread.get()

        :param id: The id of the folder (required)
        :type id: int
        :param sub_folder_id: The id of the sub folder (required)
        :type sub_folder_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FolderInformation
        """
        kwargs['_return_http_data_only'] = True
        return self.remove_folder_from_folder_with_http_info(id, sub_folder_id, **kwargs)  # noqa: E501

    def remove_folder_from_folder_with_http_info(self, id, sub_folder_id, **kwargs):  # noqa: E501
        """Remove sub folder from folder  # noqa: E501

        Remove a sub folder from a folder  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.remove_folder_from_folder_with_http_info(id, sub_folder_id, async_req=True)
        >>> result = thread.get()

        :param id: The id of the folder (required)
        :type id: int
        :param sub_folder_id: The id of the sub folder (required)
        :type sub_folder_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(FolderInformation, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'sub_folder_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_folder_from_folder" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `remove_folder_from_folder`")  # noqa: E501
        # verify the required parameter 'sub_folder_id' is set
        if self.api_client.client_side_validation and ('sub_folder_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['sub_folder_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `sub_folder_id` when calling `remove_folder_from_folder`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'sub_folder_id' in local_var_params:
            path_params['subFolderId'] = local_var_params['sub_folder_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "FolderInformation",
        }

        return self.api_client.call_api(
            '/projects/folders/{id}/folders/{subFolderId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def remove_history(self, id, history_id, **kwargs):  # noqa: E501
        """Remove history log  # noqa: E501

        Asynchronously removes history data from the project (and the data). When the remove is in progress the project status changes state to ProjectStatus.DELETING. You may query the project to check when then history element is removed. It's not sufficient to only check the ProjectStatus, since it might have status ProjectStatus.EXPLORABLE if the remove operation fails. Additionally, the exploration result of the project is marked 'outdated' to nce the history log data is removed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.remove_history(id, history_id, async_req=True)
        >>> result = thread.get()

        :param id: The id of the project (required)
        :type id: int
        :param history_id: The id of the history element (required)
        :type history_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.remove_history_with_http_info(id, history_id, **kwargs)  # noqa: E501

    def remove_history_with_http_info(self, id, history_id, **kwargs):  # noqa: E501
        """Remove history log  # noqa: E501

        Asynchronously removes history data from the project (and the data). When the remove is in progress the project status changes state to ProjectStatus.DELETING. You may query the project to check when then history element is removed. It's not sufficient to only check the ProjectStatus, since it might have status ProjectStatus.EXPLORABLE if the remove operation fails. Additionally, the exploration result of the project is marked 'outdated' to nce the history log data is removed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.remove_history_with_http_info(id, history_id, async_req=True)
        >>> result = thread.get()

        :param id: The id of the project (required)
        :type id: int
        :param history_id: The id of the history element (required)
        :type history_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'id',
            'history_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_history" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `remove_history`")  # noqa: E501
        # verify the required parameter 'history_id' is set
        if self.api_client.client_side_validation and ('history_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['history_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `history_id` when calling `remove_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'history_id' in local_var_params:
            path_params['historyId'] = local_var_params['history_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/projects/{id}/history/{historyId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def remove_model_from_project(self, id, **kwargs):  # noqa: E501
        """Detach model from project  # noqa: E501

        Detach the model from the project. If the dynamic model was created from the project, all dependent projects will receive the corresponding update. Alternatively, if the model was applied to the project, only that version of the model will be impacted. Note that the only possible update in this scenario is an update of translations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.remove_model_from_project(id, async_req=True)
        >>> result = thread.get()

        :param id: The project identifier (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.remove_model_from_project_with_http_info(id, **kwargs)  # noqa: E501

    def remove_model_from_project_with_http_info(self, id, **kwargs):  # noqa: E501
        """Detach model from project  # noqa: E501

        Detach the model from the project. If the dynamic model was created from the project, all dependent projects will receive the corresponding update. Alternatively, if the model was applied to the project, only that version of the model will be impacted. Note that the only possible update in this scenario is an update of translations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.remove_model_from_project_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: The project identifier (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_model_from_project" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `remove_model_from_project`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/projects/{id}/model', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def remove_project(self, id, **kwargs):  # noqa: E501
        """Remove project  # noqa: E501

        Removes the project. This call will return at once and the project will enter the ProjectStatus#DELETING} status. You could optionally repeatedly query the /projects endpoint to see when the project disappears.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.remove_project(id, async_req=True)
        >>> result = thread.get()

        :param id: The identifier for the project to remove (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.remove_project_with_http_info(id, **kwargs)  # noqa: E501

    def remove_project_with_http_info(self, id, **kwargs):  # noqa: E501
        """Remove project  # noqa: E501

        Removes the project. This call will return at once and the project will enter the ProjectStatus#DELETING} status. You could optionally repeatedly query the /projects endpoint to see when the project disappears.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.remove_project_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: The identifier for the project to remove (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_project" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `remove_project`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/projects/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def remove_project_from_folder(self, id, project_id, **kwargs):  # noqa: E501
        """Remove project from folder  # noqa: E501

        Removes a project from a folder (the project itself is not removed).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.remove_project_from_folder(id, project_id, async_req=True)
        >>> result = thread.get()

        :param id: The id of the folder (required)
        :type id: int
        :param project_id: The id of the project (required)
        :type project_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FolderInformation
        """
        kwargs['_return_http_data_only'] = True
        return self.remove_project_from_folder_with_http_info(id, project_id, **kwargs)  # noqa: E501

    def remove_project_from_folder_with_http_info(self, id, project_id, **kwargs):  # noqa: E501
        """Remove project from folder  # noqa: E501

        Removes a project from a folder (the project itself is not removed).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.remove_project_from_folder_with_http_info(id, project_id, async_req=True)
        >>> result = thread.get()

        :param id: The id of the folder (required)
        :type id: int
        :param project_id: The id of the project (required)
        :type project_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(FolderInformation, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'project_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_project_from_folder" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `remove_project_from_folder`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `remove_project_from_folder`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "FolderInformation",
        }

        return self.api_client.call_api(
            '/projects/folders/{id}/projects/{projectId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def remove_report(self, id, report_id, **kwargs):  # noqa: E501
        """Remove report  # noqa: E501

        Removes the project report  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.remove_report(id, report_id, async_req=True)
        >>> result = thread.get()

        :param id: The identifier for the project (required)
        :type id: int
        :param report_id: (required)
        :type report_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.remove_report_with_http_info(id, report_id, **kwargs)  # noqa: E501

    def remove_report_with_http_info(self, id, report_id, **kwargs):  # noqa: E501
        """Remove report  # noqa: E501

        Removes the project report  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.remove_report_with_http_info(id, report_id, async_req=True)
        >>> result = thread.get()

        :param id: The identifier for the project (required)
        :type id: int
        :param report_id: (required)
        :type report_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'id',
            'report_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_report" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `remove_report`")  # noqa: E501
        # verify the required parameter 'report_id' is set
        if self.api_client.client_side_validation and ('report_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['report_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `report_id` when calling `remove_report`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'report_id' in local_var_params:
            path_params['reportId'] = local_var_params['report_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/projects/{id}/reports/{reportId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def search_for_project_terms(self, id, lookfor, **kwargs):  # noqa: E501
        """Search Project Terms  # noqa: E501

        Get all the terms in the project that begin with the provided string (corpus search)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_for_project_terms(id, lookfor, async_req=True)
        >>> result = thread.get()

        :param id: The id of the project (required)
        :type id: int
        :param lookfor: String to search for. Needs to be 2 characters or more (required)
        :type lookfor: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[str]
        """
        kwargs['_return_http_data_only'] = True
        return self.search_for_project_terms_with_http_info(id, lookfor, **kwargs)  # noqa: E501

    def search_for_project_terms_with_http_info(self, id, lookfor, **kwargs):  # noqa: E501
        """Search Project Terms  # noqa: E501

        Get all the terms in the project that begin with the provided string (corpus search)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_for_project_terms_with_http_info(id, lookfor, async_req=True)
        >>> result = thread.get()

        :param id: The id of the project (required)
        :type id: int
        :param lookfor: String to search for. Needs to be 2 characters or more (required)
        :type lookfor: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[str], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'lookfor'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_for_project_terms" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `search_for_project_terms`")  # noqa: E501
        # verify the required parameter 'lookfor' is set
        if self.api_client.client_side_validation and ('lookfor' not in local_var_params or  # noqa: E501
                                                        local_var_params['lookfor'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `lookfor` when calling `search_for_project_terms`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []
        if 'lookfor' in local_var_params and local_var_params['lookfor'] is not None:  # noqa: E501
            query_params.append(('lookfor', local_var_params['lookfor']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "list[str]",
        }

        return self.api_client.call_api(
            '/projects/{id}/result/searchTerms', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def start_coverage_tonalities(self, id, **kwargs):  # noqa: E501
        """Start Coverage Tonalities Calculation  # noqa: E501

        Starts an asynchronous coverage tonalities calculation. The information returned includes tonality scores broken down for each document not included in any topic and an aggregated score for all such documents. A GET request to the same url will fetch the progress of the calculations. To be able to use this function, coverage analysis must be enabled in either the account settings (see Accounts section of docs) or the project settings (through /explorer/projects/{id}).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.start_coverage_tonalities(id, async_req=True)
        >>> result = thread.get()

        :param id: The project identifier (required)
        :type id: int
        :param sort_by_tonality: Which tonality you want to sort by. Name of tonality must be capitalized
        :type sort_by_tonality: str
        :param order_by: Which order you want the results
        :type order_by: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.start_coverage_tonalities_with_http_info(id, **kwargs)  # noqa: E501

    def start_coverage_tonalities_with_http_info(self, id, **kwargs):  # noqa: E501
        """Start Coverage Tonalities Calculation  # noqa: E501

        Starts an asynchronous coverage tonalities calculation. The information returned includes tonality scores broken down for each document not included in any topic and an aggregated score for all such documents. A GET request to the same url will fetch the progress of the calculations. To be able to use this function, coverage analysis must be enabled in either the account settings (see Accounts section of docs) or the project settings (through /explorer/projects/{id}).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.start_coverage_tonalities_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: The project identifier (required)
        :type id: int
        :param sort_by_tonality: Which tonality you want to sort by. Name of tonality must be capitalized
        :type sort_by_tonality: str
        :param order_by: Which order you want the results
        :type order_by: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'id',
            'sort_by_tonality',
            'order_by'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method start_coverage_tonalities" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `start_coverage_tonalities`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []
        if 'sort_by_tonality' in local_var_params and local_var_params['sort_by_tonality'] is not None:  # noqa: E501
            query_params.append(('sortByTonality', local_var_params['sort_by_tonality']))  # noqa: E501
        if 'order_by' in local_var_params and local_var_params['order_by'] is not None:  # noqa: E501
            query_params.append(('orderBy', local_var_params['order_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/projects/{id}/explore/coverageStatistics/tonalities', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def start_group_tonalities(self, id, group_id, tonalities_request_context, **kwargs):  # noqa: E501
        """Start tonality calculation  # noqa: E501

        Starts an asynchronous group tonalities calculation. A GET request to the same url will fetch the progress. <br/><br/> NOTE: The existing method of specifying terms and associations as query parameters has been deprecated. Please use the request body object TonalitiesRequestContext to specify these fields instead  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.start_group_tonalities(id, group_id, tonalities_request_context, async_req=True)
        >>> result = thread.get()

        :param id: The project identifier. (required)
        :type id: int
        :param group_id: The group identifier. (required)
        :type group_id: int
        :param tonalities_request_context: The context of the tonalities request, specifically with regards to terms to include. If the context element provided in the request, the corresponding query parameters are ignored. (required)
        :type tonalities_request_context: TonalitiesRequestContext
        :param terms: DEPRECATED - please use the request body object to specify terms instead. Specify the terms you are interested in getting details for. If left empty all group terms will be taken into account. One query parameter per term like this: ?terms=a_term&amp;terms=some_other_term&amp;...
        :type terms: list[str]
        :param associations: DEPRECATED - please use the request body object to specify associations instead. Optionally specify the associations you are interested in as well. Same format as for the terms: ?associations=association1&amp;associations=assoc2
        :type associations: list[str]
        :param sort_by_tonality: Which tonality you want to sort by.
        :type sort_by_tonality: str
        :param order_by: The order of the examples to return. Defaults to SENTIMENT_DESC.
        :type order_by: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.start_group_tonalities_with_http_info(id, group_id, tonalities_request_context, **kwargs)  # noqa: E501

    def start_group_tonalities_with_http_info(self, id, group_id, tonalities_request_context, **kwargs):  # noqa: E501
        """Start tonality calculation  # noqa: E501

        Starts an asynchronous group tonalities calculation. A GET request to the same url will fetch the progress. <br/><br/> NOTE: The existing method of specifying terms and associations as query parameters has been deprecated. Please use the request body object TonalitiesRequestContext to specify these fields instead  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.start_group_tonalities_with_http_info(id, group_id, tonalities_request_context, async_req=True)
        >>> result = thread.get()

        :param id: The project identifier. (required)
        :type id: int
        :param group_id: The group identifier. (required)
        :type group_id: int
        :param tonalities_request_context: The context of the tonalities request, specifically with regards to terms to include. If the context element provided in the request, the corresponding query parameters are ignored. (required)
        :type tonalities_request_context: TonalitiesRequestContext
        :param terms: DEPRECATED - please use the request body object to specify terms instead. Specify the terms you are interested in getting details for. If left empty all group terms will be taken into account. One query parameter per term like this: ?terms=a_term&amp;terms=some_other_term&amp;...
        :type terms: list[str]
        :param associations: DEPRECATED - please use the request body object to specify associations instead. Optionally specify the associations you are interested in as well. Same format as for the terms: ?associations=association1&amp;associations=assoc2
        :type associations: list[str]
        :param sort_by_tonality: Which tonality you want to sort by.
        :type sort_by_tonality: str
        :param order_by: The order of the examples to return. Defaults to SENTIMENT_DESC.
        :type order_by: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'id',
            'group_id',
            'tonalities_request_context',
            'terms',
            'associations',
            'sort_by_tonality',
            'order_by'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method start_group_tonalities" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `start_group_tonalities`")  # noqa: E501
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['group_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `group_id` when calling `start_group_tonalities`")  # noqa: E501
        # verify the required parameter 'tonalities_request_context' is set
        if self.api_client.client_side_validation and ('tonalities_request_context' not in local_var_params or  # noqa: E501
                                                        local_var_params['tonalities_request_context'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `tonalities_request_context` when calling `start_group_tonalities`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'group_id' in local_var_params:
            path_params['groupId'] = local_var_params['group_id']  # noqa: E501

        query_params = []
        if 'terms' in local_var_params and local_var_params['terms'] is not None:  # noqa: E501
            query_params.append(('terms', local_var_params['terms']))  # noqa: E501
            collection_formats['terms'] = 'multi'  # noqa: E501
        if 'associations' in local_var_params and local_var_params['associations'] is not None:  # noqa: E501
            query_params.append(('associations', local_var_params['associations']))  # noqa: E501
            collection_formats['associations'] = 'multi'  # noqa: E501
        if 'sort_by_tonality' in local_var_params and local_var_params['sort_by_tonality'] is not None:  # noqa: E501
            query_params.append(('sortByTonality', local_var_params['sort_by_tonality']))  # noqa: E501
        if 'order_by' in local_var_params and local_var_params['order_by'] is not None:  # noqa: E501
            query_params.append(('orderBy', local_var_params['order_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tonalities_request_context' in local_var_params:
            body_params = local_var_params['tonalities_request_context']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/projects/{id}/explore/groups/{groupId}/tonalities', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def start_project_document_tonalities(self, id, **kwargs):  # noqa: E501
        """Start Document Tonalities  # noqa: E501

        Starts an asynchronous document tonalities calculation. A GET request to the same url will fetch the progress of such a calculation. The result will be based on all documents in the project, unless the project has filters is applied (in which case the result be based documents that fulfil the filtering conditions).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.start_project_document_tonalities(id, async_req=True)
        >>> result = thread.get()

        :param id: The id of the project (required)
        :type id: int
        :param sort_by_tonality: Which tonality you want to sort by. Name of tonality must be capitalized.
        :type sort_by_tonality: str
        :param order_by: The order of the examples to return. Defaults to SENTIMENT_DESC.
        :type order_by: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.start_project_document_tonalities_with_http_info(id, **kwargs)  # noqa: E501

    def start_project_document_tonalities_with_http_info(self, id, **kwargs):  # noqa: E501
        """Start Document Tonalities  # noqa: E501

        Starts an asynchronous document tonalities calculation. A GET request to the same url will fetch the progress of such a calculation. The result will be based on all documents in the project, unless the project has filters is applied (in which case the result be based documents that fulfil the filtering conditions).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.start_project_document_tonalities_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: The id of the project (required)
        :type id: int
        :param sort_by_tonality: Which tonality you want to sort by. Name of tonality must be capitalized.
        :type sort_by_tonality: str
        :param order_by: The order of the examples to return. Defaults to SENTIMENT_DESC.
        :type order_by: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'id',
            'sort_by_tonality',
            'order_by'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method start_project_document_tonalities" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `start_project_document_tonalities`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []
        if 'sort_by_tonality' in local_var_params and local_var_params['sort_by_tonality'] is not None:  # noqa: E501
            query_params.append(('sortByTonality', local_var_params['sort_by_tonality']))  # noqa: E501
        if 'order_by' in local_var_params and local_var_params['order_by'] is not None:  # noqa: E501
            query_params.append(('orderBy', local_var_params['order_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/projects/{id}/explore/projectTonalities/tonalities', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def start_topic_tonalities(self, id, group_id, topic_id, tonalities_request_context, **kwargs):  # noqa: E501
        """Start tonality calculation  # noqa: E501

        Starts an asynchronous topic tonalities calculation. A GET request to the same url will fetchthe progress. <br/><br/>NOTE: The existing method of specifying terms and associations as query parameters has beendeprecated. Please use the request body object TonalitiesRequestContext tospecify these fields instead  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.start_topic_tonalities(id, group_id, topic_id, tonalities_request_context, async_req=True)
        >>> result = thread.get()

        :param id: The project identifier. (required)
        :type id: int
        :param group_id: The group identifier. (required)
        :type group_id: int
        :param topic_id: The topic identifier. The topic must belong to the group identified by the groupId parameter (required)
        :type topic_id: int
        :param tonalities_request_context: The context of the tonalities request, specifically with regards to terms to include. If the context element provided in the request, the corresponding query parameters are ignored. (required)
        :type tonalities_request_context: TonalitiesRequestContext
        :param terms: DEPRECATED - please use the request body object to specify terms instead. Specify the terms you are interested in getting details for. If left empty all group terms will be taken into account One query paramter per term like this:?terms=a_term&amp;terms=some_other_term&amp;...
        :type terms: list[str]
        :param associations: DEPRECATED - please use the request body object to specify associations instead. Optionally specify the associations you are interested in as well. Same format as for the terms: ?associations=association1&amp;associations=assoc2
        :type associations: list[str]
        :param sort_by_tonality: Which tonality you want to sort by.
        :type sort_by_tonality: str
        :param order_by: The order of the examples to return. Defaults to SENTIMENT_DESC.
        :type order_by: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.start_topic_tonalities_with_http_info(id, group_id, topic_id, tonalities_request_context, **kwargs)  # noqa: E501

    def start_topic_tonalities_with_http_info(self, id, group_id, topic_id, tonalities_request_context, **kwargs):  # noqa: E501
        """Start tonality calculation  # noqa: E501

        Starts an asynchronous topic tonalities calculation. A GET request to the same url will fetchthe progress. <br/><br/>NOTE: The existing method of specifying terms and associations as query parameters has beendeprecated. Please use the request body object TonalitiesRequestContext tospecify these fields instead  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.start_topic_tonalities_with_http_info(id, group_id, topic_id, tonalities_request_context, async_req=True)
        >>> result = thread.get()

        :param id: The project identifier. (required)
        :type id: int
        :param group_id: The group identifier. (required)
        :type group_id: int
        :param topic_id: The topic identifier. The topic must belong to the group identified by the groupId parameter (required)
        :type topic_id: int
        :param tonalities_request_context: The context of the tonalities request, specifically with regards to terms to include. If the context element provided in the request, the corresponding query parameters are ignored. (required)
        :type tonalities_request_context: TonalitiesRequestContext
        :param terms: DEPRECATED - please use the request body object to specify terms instead. Specify the terms you are interested in getting details for. If left empty all group terms will be taken into account One query paramter per term like this:?terms=a_term&amp;terms=some_other_term&amp;...
        :type terms: list[str]
        :param associations: DEPRECATED - please use the request body object to specify associations instead. Optionally specify the associations you are interested in as well. Same format as for the terms: ?associations=association1&amp;associations=assoc2
        :type associations: list[str]
        :param sort_by_tonality: Which tonality you want to sort by.
        :type sort_by_tonality: str
        :param order_by: The order of the examples to return. Defaults to SENTIMENT_DESC.
        :type order_by: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'id',
            'group_id',
            'topic_id',
            'tonalities_request_context',
            'terms',
            'associations',
            'sort_by_tonality',
            'order_by'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method start_topic_tonalities" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `start_topic_tonalities`")  # noqa: E501
        # verify the required parameter 'group_id' is set
        if self.api_client.client_side_validation and ('group_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['group_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `group_id` when calling `start_topic_tonalities`")  # noqa: E501
        # verify the required parameter 'topic_id' is set
        if self.api_client.client_side_validation and ('topic_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['topic_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `topic_id` when calling `start_topic_tonalities`")  # noqa: E501
        # verify the required parameter 'tonalities_request_context' is set
        if self.api_client.client_side_validation and ('tonalities_request_context' not in local_var_params or  # noqa: E501
                                                        local_var_params['tonalities_request_context'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `tonalities_request_context` when calling `start_topic_tonalities`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'group_id' in local_var_params:
            path_params['groupId'] = local_var_params['group_id']  # noqa: E501
        if 'topic_id' in local_var_params:
            path_params['topicId'] = local_var_params['topic_id']  # noqa: E501

        query_params = []
        if 'terms' in local_var_params and local_var_params['terms'] is not None:  # noqa: E501
            query_params.append(('terms', local_var_params['terms']))  # noqa: E501
            collection_formats['terms'] = 'multi'  # noqa: E501
        if 'associations' in local_var_params and local_var_params['associations'] is not None:  # noqa: E501
            query_params.append(('associations', local_var_params['associations']))  # noqa: E501
            collection_formats['associations'] = 'multi'  # noqa: E501
        if 'sort_by_tonality' in local_var_params and local_var_params['sort_by_tonality'] is not None:  # noqa: E501
            query_params.append(('sortByTonality', local_var_params['sort_by_tonality']))  # noqa: E501
        if 'order_by' in local_var_params and local_var_params['order_by'] is not None:  # noqa: E501
            query_params.append(('orderBy', local_var_params['order_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tonalities_request_context' in local_var_params:
            body_params = local_var_params['tonalities_request_context']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/projects/{id}/explore/groups/{groupId}/topics/{topicId}/tonalities', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def update_folder(self, folder_id, folder_request, **kwargs):  # noqa: E501
        """Update folder  # noqa: E501

        Updates the folder meta-information, such as the name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_folder(folder_id, folder_request, async_req=True)
        >>> result = thread.get()

        :param folder_id: The id of the folder (required)
        :type folder_id: int
        :param folder_request: The folder update request (required)
        :type folder_request: FolderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FolderInformation
        """
        kwargs['_return_http_data_only'] = True
        return self.update_folder_with_http_info(folder_id, folder_request, **kwargs)  # noqa: E501

    def update_folder_with_http_info(self, folder_id, folder_request, **kwargs):  # noqa: E501
        """Update folder  # noqa: E501

        Updates the folder meta-information, such as the name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_folder_with_http_info(folder_id, folder_request, async_req=True)
        >>> result = thread.get()

        :param folder_id: The id of the folder (required)
        :type folder_id: int
        :param folder_request: The folder update request (required)
        :type folder_request: FolderRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(FolderInformation, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'folder_id',
            'folder_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_folder" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'folder_id' is set
        if self.api_client.client_side_validation and ('folder_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['folder_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `folder_id` when calling `update_folder`")  # noqa: E501
        # verify the required parameter 'folder_request' is set
        if self.api_client.client_side_validation and ('folder_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['folder_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `folder_request` when calling `update_folder`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'folder_id' in local_var_params:
            path_params['folderId'] = local_var_params['folder_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'folder_request' in local_var_params:
            body_params = local_var_params['folder_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "FolderInformation",
        }

        return self.api_client.call_api(
            '/projects/folders/{folderId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def update_project(self, id, project_request, **kwargs):  # noqa: E501
        """Update project  # noqa: E501

        Updates the project name, the project specific settings or connect the project to a model. To see the possible values for project settings, along with an explanation for each field, call a GET request on this same endpoint. <br/><br/>Note that the model identified by the modelId field must be a dynamic model, in which case the project will be dependent on the model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_project(id, project_request, async_req=True)
        >>> result = thread.get()

        :param id: The identifier of the project (required)
        :type id: int
        :param project_request: The information with which to update the project (required)
        :type project_request: ProjectRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Project
        """
        kwargs['_return_http_data_only'] = True
        return self.update_project_with_http_info(id, project_request, **kwargs)  # noqa: E501

    def update_project_with_http_info(self, id, project_request, **kwargs):  # noqa: E501
        """Update project  # noqa: E501

        Updates the project name, the project specific settings or connect the project to a model. To see the possible values for project settings, along with an explanation for each field, call a GET request on this same endpoint. <br/><br/>Note that the model identified by the modelId field must be a dynamic model, in which case the project will be dependent on the model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_project_with_http_info(id, project_request, async_req=True)
        >>> result = thread.get()

        :param id: The identifier of the project (required)
        :type id: int
        :param project_request: The information with which to update the project (required)
        :type project_request: ProjectRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Project, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'project_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_project" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `update_project`")  # noqa: E501
        # verify the required parameter 'project_request' is set
        if self.api_client.client_side_validation and ('project_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_request` when calling `update_project`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'project_request' in local_var_params:
            body_params = local_var_params['project_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "Project",
        }

        return self.api_client.call_api(
            '/projects/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def update_project_model(self, id, model_input, **kwargs):  # noqa: E501
        """Update Project Model  # noqa: E501

        Updates the model to which a project is connected. If the dynamic model was created from the project, all dependent projects will receive the corresponding update. Alternatively, if the model was applied to the project, only that version of the model will be impacted. Note that the only possible update in this scenario is an update of translations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_project_model(id, model_input, async_req=True)
        >>> result = thread.get()

        :param id: The id of the project (required)
        :type id: int
        :param model_input: The information with which to update the project. (required)
        :type model_input: ModelInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Model
        """
        kwargs['_return_http_data_only'] = True
        return self.update_project_model_with_http_info(id, model_input, **kwargs)  # noqa: E501

    def update_project_model_with_http_info(self, id, model_input, **kwargs):  # noqa: E501
        """Update Project Model  # noqa: E501

        Updates the model to which a project is connected. If the dynamic model was created from the project, all dependent projects will receive the corresponding update. Alternatively, if the model was applied to the project, only that version of the model will be impacted. Note that the only possible update in this scenario is an update of translations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_project_model_with_http_info(id, model_input, async_req=True)
        >>> result = thread.get()

        :param id: The id of the project (required)
        :type id: int
        :param model_input: The information with which to update the project. (required)
        :type model_input: ModelInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Model, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'id',
            'model_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_project_model" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `update_project_model`")  # noqa: E501
        # verify the required parameter 'model_input' is set
        if self.api_client.client_side_validation and ('model_input' not in local_var_params or  # noqa: E501
                                                        local_var_params['model_input'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `model_input` when calling `update_project_model`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'model_input' in local_var_params:
            body_params = local_var_params['model_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "Model",
        }

        return self.api_client.call_api(
            '/projects/{id}/model', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def upload_project_file(self, file, file_name, **kwargs):  # noqa: E501
        """Create project  # noqa: E501

        For an authenticated user, this method will upload a CSV file that will be used to create a project. This will send the data to the server and return a response (with the project id) when the data is sent. The new project will then enter the INITIALIZING status and you may query the project (send a GET to /projects/{id}) until it changes status to EXPLORABLE}. In the case of multipart form data the parts need to be 'file' with the binary data and 'fileName' with the file name as plain text   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.upload_project_file(file, file_name, async_req=True)
        >>> result = thread.get()

        :param file: input file (required)
        :type file: file
        :param file_name: (required)
        :type file_name: str
        :param encoding: Use this parameter if you know exactly what the encoding of the file is. If nothing is provided a best guess is performed.
        :type encoding: str
        :param title: Title of the project. In absence of this parameter, the project will be initialized with a null title.
        :type title: str
        :param analyzing_column_index: The index of the column in the sheet containing the data to be analyzed. Indices are counted starting from 1.
        :type analyzing_column_index: int
        :param rows_to_analyse: The number of rows of the file provided that should be used in analysis. This parameter should be used if you do not wish to analyse all rows of the file you have uploaded but only a subset of the file.
        :type rows_to_analyse: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ProjectId
        """
        kwargs['_return_http_data_only'] = True
        return self.upload_project_file_with_http_info(file, file_name, **kwargs)  # noqa: E501

    def upload_project_file_with_http_info(self, file, file_name, **kwargs):  # noqa: E501
        """Create project  # noqa: E501

        For an authenticated user, this method will upload a CSV file that will be used to create a project. This will send the data to the server and return a response (with the project id) when the data is sent. The new project will then enter the INITIALIZING status and you may query the project (send a GET to /projects/{id}) until it changes status to EXPLORABLE}. In the case of multipart form data the parts need to be 'file' with the binary data and 'fileName' with the file name as plain text   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.upload_project_file_with_http_info(file, file_name, async_req=True)
        >>> result = thread.get()

        :param file: input file (required)
        :type file: file
        :param file_name: (required)
        :type file_name: str
        :param encoding: Use this parameter if you know exactly what the encoding of the file is. If nothing is provided a best guess is performed.
        :type encoding: str
        :param title: Title of the project. In absence of this parameter, the project will be initialized with a null title.
        :type title: str
        :param analyzing_column_index: The index of the column in the sheet containing the data to be analyzed. Indices are counted starting from 1.
        :type analyzing_column_index: int
        :param rows_to_analyse: The number of rows of the file provided that should be used in analysis. This parameter should be used if you do not wish to analyse all rows of the file you have uploaded but only a subset of the file.
        :type rows_to_analyse: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ProjectId, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'file',
            'file_name',
            'encoding',
            'title',
            'analyzing_column_index',
            'rows_to_analyse'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_project_file" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'file' is set
        if self.api_client.client_side_validation and ('file' not in local_var_params or  # noqa: E501
                                                        local_var_params['file'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `file` when calling `upload_project_file`")  # noqa: E501
        # verify the required parameter 'file_name' is set
        if self.api_client.client_side_validation and ('file_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['file_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `file_name` when calling `upload_project_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'encoding' in local_var_params and local_var_params['encoding'] is not None:  # noqa: E501
            query_params.append(('encoding', local_var_params['encoding']))  # noqa: E501
        if 'title' in local_var_params and local_var_params['title'] is not None:  # noqa: E501
            query_params.append(('title', local_var_params['title']))  # noqa: E501
        if 'analyzing_column_index' in local_var_params and local_var_params['analyzing_column_index'] is not None:  # noqa: E501
            query_params.append(('analyzingColumnIndex', local_var_params['analyzing_column_index']))  # noqa: E501
        if 'rows_to_analyse' in local_var_params and local_var_params['rows_to_analyse'] is not None:  # noqa: E501
            query_params.append(('rowsToAnalyse', local_var_params['rows_to_analyse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in local_var_params:
            local_var_files['file'] = local_var_params['file']  # noqa: E501
        if 'file_name' in local_var_params:
            form_params.append(('fileName', local_var_params['file_name']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "ProjectId",
        }

        return self.api_client.call_api(
            '/projects', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def upload_project(self, rows_data, **kwargs):  # noqa: E501
        """Create project  # noqa: E501

        For an authenticated user, this method will upload rows that will be used to create a project. This will send the data to the server and return a response (with the project id) when the data is sent. The new project will then enter the INITIALIZING status and you may query the project (send a GET to /projects/{id}) until it changes status to EXPLORABLE}. # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.upload_project(rows, async_req=True)
        >>> result = thread.get()

        :param rows_data: the rows of the project (required)
        :type rows_data: RowsData
        :param encoding: Use this parameter if you know exactly what the encoding of the file is. If nothing is provided a best guess is performed.
        :type encoding: str
        :param title: Title of the project. In absence of this parameter, the project will be initialized with a null title.
        :type title: str
        :param analyzing_column_index: The index of the column in the sheet containing the data to be analyzed. Indices are counted starting from 1.
        :type analyzing_column_index: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ProjectId
        """
        kwargs['_return_http_data_only'] = True
        return self.upload_project_with_http_info(rows_data, **kwargs)  # noqa: E501

    def upload_project_with_http_info(self, rows_data, **kwargs):  # noqa: E501
        """Create project  # noqa: E501

        For an authenticated user, this method will upload rows that will be used to create a project. This will send the data to the server and return a response (with the project id) when the data is sent. The new project will then enter the INITIALIZING status and you may query the project (send a GET to /projects/{id}) until it changes status to EXPLORABLE}.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.upload_project_with_http_info(rows, async_req=True)
        >>> result = thread.get()

        :param rows_data: the rows of the project (required)
        :type rows_data: RowsData
        :param encoding: Use this parameter if you know exactly what the encoding of the file is. If nothing is provided a best guess is performed.
        :type encoding: str
        :param title: Title of the project. In absence of this parameter, the project will be initialized with a null title.
        :type title: str
        :param analyzing_column_index: The index of the column in the sheet containing the data to be analyzed. Indices are counted starting from 1.
        :type analyzing_column_index: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ProjectId, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'rows_data',
            'encoding',
            'title',
            'analyzing_column_index'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_project" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'rows_data' is set
        if self.api_client.client_side_validation and ('rows_data' not in local_var_params or  # noqa: E501
                                                       local_var_params['rows_data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `rows_data` when calling `upload_project`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'encoding' in local_var_params and local_var_params['encoding'] is not None:  # noqa: E501
            query_params.append(('encoding', local_var_params['encoding']))  # noqa: E501
        if 'title' in local_var_params and local_var_params['title'] is not None:  # noqa: E501
            query_params.append(('title', local_var_params['title']))  # noqa: E501
        if 'analyzing_column_index' in local_var_params and local_var_params[
            'analyzing_column_index'] is not None:  # noqa: E501
            query_params.append(('analyzingColumnIndex', local_var_params['analyzing_column_index']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'rows_data' in local_var_params:
            body_params = local_var_params['rows_data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        response_types_map = {
            200: "ProjectId",
        }

        return self.api_client.call_api(
            '/projects', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def validate_filter_date_format(self, project_id, column_header_id, **kwargs):  # noqa: E501
        """Validate your data filter format  # noqa: E501

        In Explorer there is the possibility to filter your documents using meta-information. When filtering by date, it is important that the system correctly parses the date information column. This is done according to a provided value format for the input info. This API call can be used to validate the value format provided, to check the system will correctly interpret the date format in your file. Reference: <a href=\"https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_str-to-date\">https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_str-to-date</a>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.validate_filter_date_format(project_id, column_header_id, value_format, async_req=True)
        >>> result = thread.get()

        :param project_id: The id of the project (required)
        :type project_id: int
        :param column_header_id: The id of the column with date information to be validated (required)
        :type column_header_id: int
        :param value_format: The valueFormat Example: To map column data in the format '2018-06-18 11:33:23' you need a valueFormat like '%Y-%m-%d %T' (required)
        :type value_format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FilterValidation
        """
        kwargs['_return_http_data_only'] = True
        return self.validate_filter_date_format_with_http_info(project_id, column_header_id, value_format, **kwargs)  # noqa: E501

    def validate_filter_date_format_with_http_info(self, project_id, column_header_id, value_format, **kwargs):  # noqa: E501
        """Validate your data filter format  # noqa: E501

        In Explorer there is the possibility to filter your documents using meta-information. When filtering by date, it is important that the system correctly parses the date information column. This is done according to a provided value format for the input info. This API call can be used to validate the value format provided, to check the system will correctly interpret the date format in your file. Reference: <a href=\"https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_str-to-date\">https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_str-to-date</a>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.validate_filter_date_format_with_http_info(project_id, column_header_id, value_format, async_req=True)
        >>> result = thread.get()

        :param project_id: The id of the project (required)
        :type project_id: int
        :param column_header_id: The id of the column with date information to be validated (required)
        :type column_header_id: int
        :param value_format: The valueFormat Example: To map column data in the format '2018-06-18 11:33:23' you need a valueFormat like '%Y-%m-%d %T' (required)
        :type value_format: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(FilterValidation, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'project_id',
            'column_header_id',
            'value_format'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validate_filter_date_format" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `validate_filter_date_format`")  # noqa: E501
        # verify the required parameter 'column_header_id' is set
        if self.api_client.client_side_validation and ('column_header_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['column_header_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `column_header_id` when calling `validate_filter_date_format`")  # noqa: E501
        # verify the required parameter 'value_format' is set
        if self.api_client.client_side_validation and ('value_format' not in local_var_params or  # noqa: E501
                                                        local_var_params['value_format'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `value_format` when calling `validate_filter_date_format`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501
        if 'column_header_id' in local_var_params:
            path_params['columnHeaderId'] = local_var_params['column_header_id']  # noqa: E501

        query_params = []
        if 'value_format' in local_var_params and local_var_params['value_format'] is not None:  # noqa: E501
            query_params.append(('valueFormat', local_var_params['value_format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501
        
        response_types_map = {
            200: "FilterValidation",
        }

        return self.api_client.call_api(
            '/projects/{projectId}/headers/{columnHeaderId}/validateFilterFormat', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))
